// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.3
// source: fusionprime/settlement/v1/settlement.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "fusionprime.settlement.v1";

export enum CommandType {
  COMMAND_TYPE_UNSPECIFIED = 0,
  COMMAND_TYPE_DVP = 1,
  COMMAND_TYPE_COLLATERAL_TRANSFER = 2,
  UNRECOGNIZED = -1,
}

export function commandTypeFromJSON(object: any): CommandType {
  switch (object) {
    case 0:
    case "COMMAND_TYPE_UNSPECIFIED":
      return CommandType.COMMAND_TYPE_UNSPECIFIED;
    case 1:
    case "COMMAND_TYPE_DVP":
      return CommandType.COMMAND_TYPE_DVP;
    case 2:
    case "COMMAND_TYPE_COLLATERAL_TRANSFER":
      return CommandType.COMMAND_TYPE_COLLATERAL_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandType.UNRECOGNIZED;
  }
}

export function commandTypeToJSON(object: CommandType): string {
  switch (object) {
    case CommandType.COMMAND_TYPE_UNSPECIFIED:
      return "COMMAND_TYPE_UNSPECIFIED";
    case CommandType.COMMAND_TYPE_DVP:
      return "COMMAND_TYPE_DVP";
    case CommandType.COMMAND_TYPE_COLLATERAL_TRANSFER:
      return "COMMAND_TYPE_COLLATERAL_TRANSFER";
    case CommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EventStatus {
  EVENT_STATUS_UNSPECIFIED = 0,
  EVENT_STATUS_INITIATED = 1,
  EVENT_STATUS_CONFIRMED = 2,
  EVENT_STATUS_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function eventStatusFromJSON(object: any): EventStatus {
  switch (object) {
    case 0:
    case "EVENT_STATUS_UNSPECIFIED":
      return EventStatus.EVENT_STATUS_UNSPECIFIED;
    case 1:
    case "EVENT_STATUS_INITIATED":
      return EventStatus.EVENT_STATUS_INITIATED;
    case 2:
    case "EVENT_STATUS_CONFIRMED":
      return EventStatus.EVENT_STATUS_CONFIRMED;
    case 3:
    case "EVENT_STATUS_FAILED":
      return EventStatus.EVENT_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventStatus.UNRECOGNIZED;
  }
}

export function eventStatusToJSON(object: EventStatus): string {
  switch (object) {
    case EventStatus.EVENT_STATUS_UNSPECIFIED:
      return "EVENT_STATUS_UNSPECIFIED";
    case EventStatus.EVENT_STATUS_INITIATED:
      return "EVENT_STATUS_INITIATED";
    case EventStatus.EVENT_STATUS_CONFIRMED:
      return "EVENT_STATUS_CONFIRMED";
    case EventStatus.EVENT_STATUS_FAILED:
      return "EVENT_STATUS_FAILED";
    case EventStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SettlementCommand {
  commandId: string;
  workflowId: string;
  accountRef: string;
  asset?:
    | Asset
    | undefined;
  /** decimal encoded string for high precision */
  amount: string;
  deadlineIso8601: string;
  type: CommandType;
}

export interface SettlementEvent {
  eventId: string;
  commandId: string;
  workflowId: string;
  status: EventStatus;
  statusReason: string;
  occurredAtIso8601: string;
  payer: string;
  payee: string;
  chainId: string;
}

export interface Asset {
  chainId: string;
  tokenAddress: string;
  symbol: string;
}

function createBaseSettlementCommand(): SettlementCommand {
  return { commandId: "", workflowId: "", accountRef: "", asset: undefined, amount: "", deadlineIso8601: "", type: 0 };
}

export const SettlementCommand: MessageFns<SettlementCommand> = {
  encode(message: SettlementCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.accountRef !== "") {
      writer.uint32(26).string(message.accountRef);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(34).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.deadlineIso8601 !== "") {
      writer.uint32(50).string(message.deadlineIso8601);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SettlementCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlementCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountRef = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deadlineIso8601 = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SettlementCommand {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      accountRef: isSet(object.accountRef) ? globalThis.String(object.accountRef) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      deadlineIso8601: isSet(object.deadlineIso8601) ? globalThis.String(object.deadlineIso8601) : "",
      type: isSet(object.type) ? commandTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: SettlementCommand): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.accountRef !== "") {
      obj.accountRef = message.accountRef;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.deadlineIso8601 !== "") {
      obj.deadlineIso8601 = message.deadlineIso8601;
    }
    if (message.type !== 0) {
      obj.type = commandTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SettlementCommand>): SettlementCommand {
    return SettlementCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SettlementCommand>): SettlementCommand {
    const message = createBaseSettlementCommand();
    message.commandId = object.commandId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.accountRef = object.accountRef ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.amount = object.amount ?? "";
    message.deadlineIso8601 = object.deadlineIso8601 ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSettlementEvent(): SettlementEvent {
  return {
    eventId: "",
    commandId: "",
    workflowId: "",
    status: 0,
    statusReason: "",
    occurredAtIso8601: "",
    payer: "",
    payee: "",
    chainId: "",
  };
}

export const SettlementEvent: MessageFns<SettlementEvent> = {
  encode(message: SettlementEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    if (message.workflowId !== "") {
      writer.uint32(26).string(message.workflowId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.statusReason !== "") {
      writer.uint32(42).string(message.statusReason);
    }
    if (message.occurredAtIso8601 !== "") {
      writer.uint32(50).string(message.occurredAtIso8601);
    }
    if (message.payer !== "") {
      writer.uint32(58).string(message.payer);
    }
    if (message.payee !== "") {
      writer.uint32(66).string(message.payee);
    }
    if (message.chainId !== "") {
      writer.uint32(74).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SettlementEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlementEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statusReason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.occurredAtIso8601 = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payer = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payee = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SettlementEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      status: isSet(object.status) ? eventStatusFromJSON(object.status) : 0,
      statusReason: isSet(object.statusReason) ? globalThis.String(object.statusReason) : "",
      occurredAtIso8601: isSet(object.occurredAtIso8601) ? globalThis.String(object.occurredAtIso8601) : "",
      payer: isSet(object.payer) ? globalThis.String(object.payer) : "",
      payee: isSet(object.payee) ? globalThis.String(object.payee) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
    };
  },

  toJSON(message: SettlementEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.status !== 0) {
      obj.status = eventStatusToJSON(message.status);
    }
    if (message.statusReason !== "") {
      obj.statusReason = message.statusReason;
    }
    if (message.occurredAtIso8601 !== "") {
      obj.occurredAtIso8601 = message.occurredAtIso8601;
    }
    if (message.payer !== "") {
      obj.payer = message.payer;
    }
    if (message.payee !== "") {
      obj.payee = message.payee;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<SettlementEvent>): SettlementEvent {
    return SettlementEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SettlementEvent>): SettlementEvent {
    const message = createBaseSettlementEvent();
    message.eventId = object.eventId ?? "";
    message.commandId = object.commandId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.status = object.status ?? 0;
    message.statusReason = object.statusReason ?? "";
    message.occurredAtIso8601 = object.occurredAtIso8601 ?? "";
    message.payer = object.payer ?? "";
    message.payee = object.payee ?? "";
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { chainId: "", tokenAddress: "", symbol: "" };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.tokenAddress !== "") {
      writer.uint32(18).string(message.tokenAddress);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      tokenAddress: isSet(object.tokenAddress) ? globalThis.String(object.tokenAddress) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.tokenAddress !== "") {
      obj.tokenAddress = message.tokenAddress;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.chainId = object.chainId ?? "";
    message.tokenAddress = object.tokenAddress ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
